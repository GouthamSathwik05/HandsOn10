# -*- coding: utf-8 -*-
"""HandsOn10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fyFw0SxM_GuTTT_ib-b72D6EhVwmeQaK
"""

class Node:
  def __init__(self, key):
    self.left=None
    self.right=None
    self.val=key

class BST:
  def insert(self, root, key):
    if root is None:
      return Node(key)
    else:
      if key<root.val:
        root.left=self.insert(root.left, key)
      else:
        root.right=self.insert(root.right, key)
    return root

  def search(self, root, key):
    if root is None or root.val==key:
      return root
    if key<root.val:
      return self.search(root.left, key)
    return self.search(root.right, key)

  def delete(self, root, key):
    if root is None:
      return root
    if key<root.val:
      root.left=self.delete(root.left, key)
    elif key>root.val:
      root.right=self.delete(root.right, key)
    else:
      if root.left is None:
        return root.right
      elif root.right is None:
        return root.left
      temp=self.min_value_node(root.right)
      root.val=temp.val
      root.right=self.delete(root.right, temp.val)
    return root

  def min_value_node(self, node):
    current=node
    while current.left is not None:
      current=current.left
    return current

# Testing BST
if __name__ == "__main__":
  bst=BST()
  root=None
  keys=[20, 10, 30, 5, 15, 25, 35]
  for key in keys:
    root=bst.insert(root, key)
# Search for a key
  assert bst.search(root, 15) is not None
  assert bst.search(root, 100) is None

  root = bst.delete(root, 10)
  assert bst.search(root, 10) is None

class RBNode:
  def __init__(self, data):
    self.data=data
    self.color='red'  # New nodes are red
    self.left=None
    self.right=None
    self.parent=None

class RedBlackTree:
  def __init__(self):
    self.NIL_LEAF=RBNode(0)
    self.NIL_LEAF.color='black'
    self.root=self.NIL_LEAF

  def insert(self, key):
    new_node=RBNode(key)
    new_node.left=self.NIL_LEAF
    new_node.right=self.NIL_LEAF
    self._insert_node(new_node)
    self._fix_violation(new_node)

  def _insert_node(self, new_node):
    parent=None
    current=self.root
    while current!=self.NIL_LEAF:
      parent=current
      if new_node.data<current.data:
        current=current.left
      else:
        current=current.right
    new_node.parent = parent
    if parent is None:
      self.root=new_node
    elif new_node.data<parent.data:
      parent.left=new_node
    else:
      parent.right=new_node

  def _fix_violation(self, new_node):
    while new_node!=self.root and new_node.parent.color=='red':
      if new_node.parent==new_node.parent.parent.left:
        uncle=new_node.parent.parent.right
        if uncle.color=='red':
          new_node.parent.color='black'
          uncle.color='black'
          new_node.parent.parent.color='red'
          new_node=new_node.parent.parent
        else:
          if new_node==new_node.parent.right:
            new_node=new_node.parent
            self._left_rotate(new_node)
          new_node.parent.color='black'
          new_node.parent.parent.color='red'
          self._right_rotate(new_node.parent.parent)
      else:
        uncle=new_node.parent.parent.left
        if uncle.color=='red':
          new_node.parent.color='black'
          uncle.color='black'
          new_node.parent.parent.color='red'
          new_node=new_node.parent.parent
        else:
          if new_node==new_node.parent.left:
            new_node=new_node.parent
            self._right_rotate(new_node)
          new_node.parent.color='black'
          new_node.parent.parent.color='red'
          self._left_rotate(new_node.parent.parent)
    self.root.color = 'black'

  def _left_rotate(self, x):
    y=x.right
    x.right=y.left
    if y.left!=self.NIL_LEAF:
      y.left.parent=x
    y.parent=x.parent
    if x.parent is None:
      self.root=y
    elif x==x.parent.left:
      x.parent.left=y
    else:
      x.parent.right=y
    y.left=x
    x.parent=y

  def _right_rotate(self, x):
    y=x.left
    x.left=y.right
    if y.right!=self.NIL_LEAF:
      y.right.parent=x
    y.parent=x.parent
    if x.parent is None:
      self.root=y
    elif x==x.parent.right:
      x.parent.right=y
    else:
      x.parent.left=y
    y.right=x
    x.parent=y

  def search(self, key):
    return self._search_node(self.root, key)

  def _search_node(self, node, key):
    if node==self.NIL_LEAF or key==node.data:
      return node
    if key<node.data:
      return self._search_node(node.left, key)
    return self._search_node(node.right, key)

  def inorder(self):
    self._inorder_helper(self.root)

  def _inorder_helper(self, node):
    if node!=self.NIL_LEAF:
      self._inorder_helper(node.left)
      print(node.data, end=' ')
      self._inorder_helper(node.right)

# Example Tests
if __name__ == "__main__":
  rbt = RedBlackTree()
  values = [10, 20, 30, 15, 25, 5]
  for value in values:
    rbt.insert(value)
  print("Inorder Traversal of Red-Black Tree:")
  rbt.inorder()

class AVLNode:
  def __init__(self, key):
    self.key=key
    self.left=None
    self.right=None
    self.height=1

class AVLTree:
  def insert(self, root, key):
    if not root:
      return AVLNode(key)
    elif key<root.key:
      root.left=self.insert(root.left, key)
    else:
      root.right=self.insert(root.right, key)
    root.height=1+max(self.get_height(root.left), self.get_height(root.right))
    balance=self.get_balance(root)

    if balance>1 and key<root.left.key:
      return self.right_rotate(root)

    if balance<-1 and key>root.right.key:
      return self.left_rotate(root)

    if balance>1 and key>root.left.key:
      root.left=self.left_rotate(root.left)
      return self.right_rotate(root)

    if balance<-1 and key<root.right.key:
      root.right=self.right_rotate(root.right)
      return self.left_rotate(root)
    return root

  def left_rotate(self, z):
    y=z.right
    T2=y.left
    y.left=z
    z.right=T2
    z.height=1+max(self.get_height(z.left), self.get_height(z.right))
    y.height=1+max(self.get_height(y.left), self.get_height(y.right))
    return y

  def right_rotate(self, z):
    y=z.left
    T3=y.right
    y.right=z
    z.left=T3
    z.height=1+max(self.get_height(z.left), self.get_height(z.right))
    y.height=1+max(self.get_height(y.left), self.get_height(y.right))
    return y

  def get_height(self, root):
    if not root:
      return 0
    return root.height

  def get_balance(self, root):
    if not root:
      return 0
    return self.get_height(root.left) - self.get_height(root.right)

  def inorder(self, root):
    if root:
      self.inorder(root.left)
      print(root.key, end=' ')
      self.inorder(root.right)

if __name__ == "__main__":
  avl=AVLTree()
  root=None
  values=[10, 20, 30, 25, 5]
  for value in values:
    root=avl.insert(root, value)
  print("\nInorder Traversal of AVL Tree:")
  avl.inorder(root)